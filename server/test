
### Step-by-Step Explanation

1. **Initialize `read_set` and `write_set`**:
    ```cpp
    FD_ZERO(&read_set);
    memcpy(&read_set, &master_set, sizeof(master_set)); 
    FD_ZERO(&write_set);
    memcpy(&write_set, &master_set, sizeof(master_set)); 
    ```
    - `FD_ZERO(&read_set)` and `FD_ZERO(&write_set)` initialize the file descriptor sets `read_set` and `write_set` to be empty.
    - `memcpy(&read_set, &master_set, sizeof(master_set))` copies the `master_set` (which contains all the file descriptors we are monitoring) into `read_set` and `write_set`.

2. **Call `select`**:
    ```cpp
    if (select(maxFds + 1, &read_set, &write_set, NULL, NULL) < 0) {
        throw ServerMonitorException("Select error");
    }
    ```
    - `select(maxFds + 1, &read_set, &write_set, NULL, NULL)` waits for any of the file descriptors in `read_set` or `write_set` to become ready for reading or writing, respectively.
    - `maxFds + 1` is the highest-numbered file descriptor plus one.
    - If `select` returns a value less than 0, it indicates an error, and an exception is thrown.

3. **Iterate over file descriptors**:
    ```cpp
    for (int i = 0; i <= maxFds; ++i)
    {
        if (FD_ISSET(i, &read_set)) {
    ```
    - The loop iterates over all possible file descriptors from 0 to `maxFds`.
    - `FD_ISSET(i, &read_set)` checks if file descriptor `i` is set in `read_set`, meaning it is ready for reading.

4. **Handle new connections**:
    ```cpp
    if (sockets.find(i) != sockets.end()) {
        struct sockaddr_in client_address;
        socklen_t client_address_len = sizeof(client_address);

        int new_socket = accept(i, (struct sockaddr *)&client_address, &client_address_len);
        if (new_socket < 0) {
            Logger(Logger::ERROR, "Accept Error");
            continue;
        }
        FD_SET(new_socket, &master_set);
        if (new_socket > maxFds)
            maxFds = new_socket;

        tmpSockets[new_socket] = sockets[i];
        {
            std::stringstream ss;
            ss << "WebSocket connection established with " << tmpSockets[new_socket]->getConfig()->getName();
            Logger(Logger::INFO, ss.str());
        }
    }
    ```
    - `sockets.find(i) != sockets.end()` checks if `i` is a listening socket.
    - `accept(i, (struct sockaddr *)&client_address, &client_address_len)` accepts a new connection on the listening socket `i`.
    - If `accept` returns a negative value, it indicates an error, and an error message is logged.
    - `FD_SET(new_socket, &master_set)` adds the new socket to `master_set`.
    - `maxFds` is updated if `new_socket` is greater than the current `maxFds`.
    - `tmpSockets[new_socket] = sockets[i]` associates the new socket with the server configuration.

5. **Handle data from existing connections**:
    ```cpp
    else {
        char buffer[BUFFER_SIZE] = {0};
        int bytes_read = recv(i, buffer, sizeof(buffer), 0);

        std::stringstream ss;
        ss << "WebSocket message received from " << tmpSockets[i]->getConfig()->getName() << ":" << tmpSockets[i]->getConfig()->getPort();
        Logger(Logger::INFO, ss.str());

        if (bytes_read <= 0) {
            if (bytes_read == 0)
                Logger(Logger::INFO, "Connection closed");
            else
                Logger(Logger::ERROR, "Recv Error");
            close(i);
            update_maxFds();
            tmpSockets.erase(i);
            FD_CLR(i, &master_set);
        } else {
            buffer[bytes_read] = 0;
            std::string response = "<h1>Hello, world!</h1>";
            std::stringstream ss;
            ss << "HTTP/1.1 200 OK";
            Logger(Logger::DEBUG, ss.str());
            ss << "\r\nContent-Type: text/html\r\n";
            ss << "Content-Length: " << response.size() << "\r\n\r\n";
            ss << response;
            if (FD_ISSET(i, &write_set)) {
                std::stringstream xx;
                xx << "Sender connection from socket " << i;
                Logger(Logger::DEBUG, xx.str());
                send(i, ss.str().c_str(), ss.str().size(),