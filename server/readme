
<h1>Sockets Documentation<h1>

# a Socket :  a way to speak to other programs using "standard unix file descriptor"
		! can work with read and write but
		* send() & recv() is better and offer more control
		we work with "internet sockets" devide into two types :
	## Stream Sockets (SOCK_STREAM) <two-way connnected connection stream>
		.telnet, ssh : uses this type of sockets
			=> all the characters you type arrive in the same order you type them
		. web browsers (HTTP) uses this type too
		!=> they achieve this high level of data transimission quality using :TCP(Transmission Control Protocol)
			*TCP makes sure your data arrives sequentially and error-free
				use IP for routing (TCP/IP)
		!=> used for accuracy
	## Datagram Sockets (SOCK_DGRAM)
		!=> they use UDP(User Datagram Protocol)
			. data may arrive
			. it may arrive out of order
			. if it arrives , the data within the packet will be error-free
		!=> connectionless sockets :
			. you dont have to maintain an open connection
				.just build a packet, slap an ip header on it with destination info & send it
			.they used either when TCP stack is unavailable or when few dropped packets here and there
		. tftp, dhcpcd (they have their own protocol on top of UDP)
		. multiplayer games, streaming audio, video conferencing ...
		!=> used for SPEED

# Data encapsulation
	[ Ethernet [ IP [ UDP [ TFTP [ DATA ] ] ] ] ]
	when sent :
		> packet is born (creating data)
			> encapsulated in a first protocol TFTP (encapsulating it using methods of my choice and send it )
				> encapsulated in the next protocol UDP (kernel build transport layer)
					> again the IP (kernel build internet layer)
						> final protocol on the hardware (physical layer) ETHERNET (hardware does the network access layer)
	when received:
						> hardware strips the ETHERNET header
					> kernel strips the IP and UDP headers
				> TFTP program strips TFTP header
			> finally getting the data

# network used layers
	. Application Layer (telnet, ftp ...)
	. Host-to-host Transport Layer (TCP, UDP)
	. Internet Layer (IP and routing)
	. Network Access Layer (Ethernet, wifi...)

# IP ADRESSES , struct S and Data Munging
	##Port Numbers (used by TCP, UDP too , not only IP)
		/* you want to have a computer that handles the incpming mail and web services: how doyou differentiate ebtween the two on a computer with a single IP address (check /etc/services) */
	##Byte order (h:host, to, n:network, s:short, l:long)
		-htons(), htonl()
		-ntohs(), ntohl()
	##struct s:
		> socket descriptor : int
		> struct addrinfo {
			int ai_flags 					: AI_PASSIVE(assign my local host address to socket struct), AI_CANONNAME, etc
			int ai_family 					: AF_INET, AF_INET6, AF_UNSPEC (IP verison)
			int ai_socktype 				: SOCK_STREAM, SOCK_DGRAM
			int ai_protocol 				: use 0 for any
			size_t ai_addrlen 				: size of ai_addr in bytes
			struct sockaddr *ai_addr 		{
				unsigned short	sa_family;	 : address family , AF_XXX
				char			sa_data[14]; : 14 bytes of protocol address (contain a dest address and port number for the socket)
			}: by calling getaddrinfo()
			char *ai_canonname 				: full cononical hostname

			struct addrinfo *ai_next 		: linked list, next node
		}
			> we load the struct up a bit, then call getaddrinfo(): pointer to new linked list
			> to deal with sockaddr, struct sockaddr_in invented for internet (IPv4) and can be casted to sockaddr and vice versa
				> struct sockaddr_in {
					short int	sin_family; // same ai_family
					unsigned short int	sin_port; // must be in nETWORK BYTE ORDER USING htons()
					struct in_addr	sin_addr;
					unsgined char	sin_zero[8]; (included to pad to the same size as sockaddr and should be set to all zeros by memset())
				}
		> struct sockaddr_storage {
			sa_family_t ss_family; //address family (cast it to struct sockaddr_in)

			<!- else made for padding char, int42_t,  char -->
		}
	##IP adresses (V4, V6) : manupilate IP addresses
		> assume we have struct sockaddr_in and we have an IP 1.1.1.1 (IPv4) to store into it :
			- inet_pton(family, ip, &(struct to store in)) : convert ipaddress into struct in_addr depends on the family AF_INET : returns -1 on error, 0 is messed up
			- inet_ntop(family, &(struct where stored), buffer ip, sizeOfIp(INET_ADDRSTRELN)) : convert struct in_addr to IP
	##Privacy or Disconnection Networks
		>to hide or show your address to the outer world, IP addresses using a process called Nework Address Translation (NAT)

# System Calls or Bust
	## getaddrinfo() - prepare to launch!
		>#include <sys/types.h> <sys/socket.h> <netdb.h>
		> int getaddrinfo(	const char *node,				//DNS or IP
							const char *service,			//http or port number, ftp...
							const struct addrinfo *hints,	// points to struct addrinfo that you filled out before
							struct addrinfo **res);
		> Error : non-zero , use gai_strerror()
		> we can free it all using freeaddrinfo(struct addrinfo*)	
	##socket() - get the file descriptor
		>#include <sys/types.h> <sys/socket.h>
		> int socket (	int domain, 	//PF_INET, PF_INET6
						int type,		//SOCK_STREAM, SOCK_DGRAM
						int protocol);	// 0 or call getprotobyname("name:tcp, udp")
		> Error : -1
	##bind() - what port am i on?
		* commonly used if you going to 'listen()' for incoming connections on a specific port
		* unnecessary if you are a client not a server that use 'connect()'
		>#include <sys/types.h> <sys/socket.h>
		> int bind(	int sockfd,					// socket file descriptor
					struct sockaddr *my_addr,	// pointer to sockaddr
					int addrlen);				// lenght in bytes of the addr
		>Error : -1
		*all ports < 1024 are RESERVED (unless sudo) until 65535
		*socket may hang for a while after rebooting it
	##connect()
		>int connect(	int sockfd,						//socket fd
						struct sockaddr *serve_addr,	// contain destination port & IP
						int addrlen);					//len in bytes of server address struct
		> Error : -1
		*we may not call bind() since we only care where were going(remote port), kernel will choose a local port for us
	##listen() - please call me ?
		*you dont want to connect localy, but wait for incoming connections and handle them
				- first listen()
				- then accept()
		> int listen (	int sockfd,		//socked fd
						int backlog);	//number of connections allowed on the incoming queue->
							= incoming connections giong got wait int this queue until you accept() them
		> Error : -1
		* we need to call bind() before listen: so server is running on a specific port
			* getaddrinfo() -> socket() -> bind() -> listen() -> accept()
	##accept()  - "thanks for calling port 3303"
		*someone need to connect() on a port that you are listen(), their connection would be queued until accept() by you , to get the pending connection => return brand new socket fd to use for this single connection. now you have two sockets:original one is still listening for more connections, pending one is ready for send() & recv()
		> int accept(	int				sockfd,
						struct sockaddr *addr,		//usually a pointer to local struct sockaddr_storage to determine which host is calling in which port
						socklen_t 		*addrlen);	// sizeof(struct sockaddr_storage)
		>Error : -1
	##send() & recv() - talk to me, Baby!
		*used for communicationg over stream sockets or connected datagram sockets (blocking calls)
		>int send(	int 		sockfd, 	//whetever it is from socket() or accept()
					const void 	*msg,		//pointer to data you want to send
					int			len,		//len of the data in bytes
					int			flags);		// set it to 0
			> return number of bytes sent out , may be (< len)
			>Error : -1
		>int recv(	int 	sockfd,
					void 	*buf,		//buff to read the info into
					int 	len,		//max len of buff
					int		flags);		//set it to 0
			>return byte read into the buff
			> Error : -1, 0 if remote side has closed connection on you
	##close():
		close(sockfd) : close the fd from any read and write

	##getpeername() - who are you?
		>int getpeername(	int				sockfd,
							struct sockaddr	*addr,		//hold the info of the other side connection
							int				*addrlen);	//pointer to int(sizeof(strcut sockaddr))
		>Error : -1

# Client-server Background
	often will only be one server on a machine, handle multiple clients using fork()
		1 - server will wait for a connection
		2 - accept() it
		3 - fork() a child to handle it

# Advanced techniques
	## Blocking
		.accept() , all recv() blocks because they are allowed to
			. when creating a socket by kernel sets them into blocking
				.you can control it by fctnl() : O_NONBLOCK
				.then we you try to read from if no data return -1 (consume CPU)
					. there is a better way to is to poll

	## Poll() - Synchronous I/O Multiplexing
		>#include <poll.h>
		*monitor bunch of sockets at once, then handle the ones that have data ready
		!!! horribly slow when large numbers of connections
		** using poll() telling the OS to do all the work for us, and let us know when some data is ready on which sockets and process can go to sleep to save resources
		> int poll(	struct pollfds 	fds[],		//our array of info(sockets to monitor)
					nfds_t			nfds,		//count of elements in the fds[]
					int				timeout);	//timeout in ms or < 0 to wait forever
		> return number of elements in the array that have had an event occur
				>> struct pollfds {
					int 	fd;			//socket descriptor
					short	events;		//bitmap of events we"re intereseted in (POLLIN, POLLOUT, POLLHUP)
					shorts	revents;	//when poll() returns, bitmap of events that occured
				}
		> when poll returns : check the revents field to see if POLLIN or POLLOUT is set, that event occured
			*to modify the pollfds , just have enough space or realloc()
			*making fd < 0 : make poll ignore it
			*to make a chat: start by one socket listener in the poll to get new connections that added to the fds dynamically afterward
			*to delete: copy the last one into the one we try to delete and substract the len of fds
	
	## Select() - Synchronous I/O multiplexing, Old School
		*a server that want to listen to incoming connections as well keep reading from connections he already have : if :accept() and recv() but you may block on accept, and cant read on recv
			**select() monitor several sockets at the same time, tell you which ready to write, and which have raised exceptions
		!!!terribaly slow when huge numbers of connections
		> int select (	int 			numfds,
						fd_set			*readfds,
						fd_set			*writefds,
						fd_set			*exceptfds,
						struct timeval	*timeout{int  tv_sec, int tv_usec});	//num of time to wait
		* manages sets of fds(read, write, except):
				.to check if you can read from stdin 0 or anyother fds, add them to the set readfds
				.numfds should be set to the values of the highest file descript + 1
				.>as return : readfds will be modified to reflect which of the fds selected ready to read ==> test them with the macro FD_ISSET()
			>manupilate those sets using Macros of type fd_set
				- FD_SET(int fd, fd_set *set)		//add fd to the set
				- FD_CLR(int fd, fd_set *set)		// Remove fd from the set
				- FD_ISSET(int fd, fd_set *set)		// Return true if fd is in the set
				- FD_ZERO(fd_set *set)				// Clear all entries from the set
			! if we set timeval to 0 : select() will timeout immediatly, polling all the fds in your sets
			! if we set timeval to NULL : it will never timeout and will wait untilt he first fd is ready
		? if socket in readset is closed , select() return ot as ready, when we try to use it (recv) will return 0
		! if socket made in listen() . we can check on new connections by putting it in readfds
	
	## Send() - handling partial sends
		*might not send all the bytes we ask it for.
			.want to send 512bytes but send() only 412 bytes: the remaining bytes been kept in my buffer waiting to be sent {handling it to send it all through a loop of calculation}
		
	## Serialization - how to pack data
	## Son of Data Encapsulation
		*sticking a header on there with either some ID or packet length or both (binary data)
			/*	chatting group, sending eachother messages and merged if we dont define a struct to them*/ => marshal and unmarshal as packing and unpacking

